<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Formality</title>
      <link href="/2022/06/29/Formality/"/>
      <url>/2022/06/29/Formality/</url>
      
        <content type="html"><![CDATA[<p>Formality</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>形式验证是一种系统化方法，用穷举的算法技术证明设计实现满足设计规范的特征。其覆盖了输入的所有可能序列，不需要开发测试向量，能够检查所有的边角逻辑，提供了完整的测试覆盖率。</p><p>在IC的流程中通常用于进行不同流程步骤的Netlist的比较：</p><ul><li>逻辑综合 Netlist</li><li>Floorplan Netlist</li><li>Placement Netlist</li><li>CTSinserted Netlist</li><li>P&amp;R Netlist</li></ul><p>每一个步骤后都会有新的逻辑加入到Netlist中，但需要保证这个新的逻辑的加入不会改变之间Netlist的功能。</p><h1 id="涉及名词及概念"><a href="#涉及名词及概念" class="headerlink" title="涉及名词及概念"></a>涉及名词及概念</h1><ul><li><em>Reference Design</em>: 初始Verilog电路设计</li><li><em>Implementation</em> Netlist: 综合后电路网表</li></ul><h2 id="Compare-Point"><a href="#Compare-Point" class="headerlink" title="Compare Point"></a>Compare Point</h2><p>Formality uses the following design objects to create compare point automatically:</p><ul><li>Primary Output Port</li><li>Sequential Element(Register, Latch)</li><li>Black Box(Input Pins)</li><li>Nets driven by multiple drivers, where at least one driver is a port or black box</li></ul><p>Formality依据上诉规则自动创建 compare point，除此之外用户也可自定义创新compare point。</p><p><img src="/2022/06/29/Formality/Formality\compare_point.png" alt="compare point"></p><h2 id="Logic-Cones"><a href="#Logic-Cones" class="headerlink" title="Logic Cones"></a>Logic Cones</h2><p><img src="/2022/06/29/Formality/Formality\logic_cones.PNG" alt="logic core"></p><p>Logic Cones包含从一个design object作为起始位，往回回溯到另一design object为止的中间所有组合逻辑。</p><p>对于Formality来说，Logic Cones中的起始点为Formality中的Compare Points，终点为Primary Inputs or Compare points。</p><p>由于在Formality中寄存器被当作比较点，因此logic cones只能是组合逻辑的集合。</p><h2 id="Black-Box"><a href="#Black-Box" class="headerlink" title="Black Box"></a>Black Box</h2><p><em>A black box is an instance of a design whose function isunknown. Black boxes are</em><br><em>commonly used for components of a design that are not synthesized. Examples ofcommon</em><br><em>black boxes include RAMs, ROMS, analog circuits, and hard IP blocks.</em></p><p><em>The inputs to black boxes are treated as compare points andthe outputs of the black boxes are treated as input points to other logic cones.</em></p><p>Black Box主要是一些内部功能未知的模块，因此其中间逻辑不作为Logic Cones，此外Black Box的输入被认为是一个compare point</p><h1 id="验证原理"><a href="#验证原理" class="headerlink" title="验证原理"></a>验证原理</h1><p>Formality找到reference design 和implementation design 二者相对应的 compare points，把相邻两个compare point 之间的组合逻辑电路转化为数学模型，把每一个compare point的所有输入的逻辑情况都遍历一遍，比较二者是否一致，既比较Reference Design和Implementation Netlist对应每一个compare point 在输入相同的情况下所得到的逻辑输出值是否相同。</p><p>相邻两个compare point 间均为一些组合逻辑电路，Formality的主要工作就是比较这两个组合逻辑电路的功能是否一致。</p><h2 id="比较算法-Matching"><a href="#比较算法-Matching" class="headerlink" title="比较算法(Matching)"></a>比较算法(Matching)</h2><p>确定compare point后，需要以一种确定的方法将reference design中的compare point与implementation netlist中的进行对应。</p><ul><li>Name-based matching technique: 通过object-name进行对应</li><li>User-match：在基于name-based matching中若部分compare point未找到对应，可通过下述命令report，并进行手工对应:</li></ul><p>​                                                    <strong><em>report_unmatched_points</em></strong></p><ul><li>Topological Equivalence: 假设两个没有对应的compare point的logic crone在拓扑上是一样的，则认为该两个compare point是对应的。</li><li>Signature Analysis: Signature  Analysis是对设计中compare point的功能和拓扑签名的迭代分析。功能签名由随机输入的仿真pattern驱动；拓扑签名来源于Logic cones的拓扑结构。</li></ul><p>Design Consistency: 设计一致性，要求不同设计在面对相同的input pattern时产生相同的输出响应。但当某设计输出存在<font color="red"><strong>X</strong></font>状态，而另一个设计响应未0、1时也可称为等价。</p><p>Design Equality: 设计相等，与Design Consistency类似，但对于<font color="red"><strong>X</strong></font>状态，要求对应的设计输出也为<font color="red"><strong>X</strong></font>状态。</p><p>Formality基于Logic Cones来做等效性检查，当Reference Design的所有Compare point的Logic Cones和Implementation Netlist中的均<strong><em>一致</em></strong>，则称该两电路等效。</p><p>通常Implementation Netlist中的Compare Point数量大于Reference Design（有新逻辑加入设计）。</p><h1 id="验证思路"><a href="#验证思路" class="headerlink" title="验证思路"></a>验证思路</h1><p>传统的后仿标准流程需要将综合后的SDF文件内的时序信息反标到Verilog网表中再次进行动态后仿真，该种方案的缺点主要有：</p><ul><li>动态后仿真的代码覆盖率基于输入激励pattern的完备性，人为设计输出向量很难实现100%覆盖</li><li>消耗时间较多，不适用于大规模复杂的电路</li></ul><p>对于仿真而言，电路的逻辑功能的正确性可以由RTL或者门级的功能仿真来保证；其次，电路的时序是否满足可以通过STA（静态时序分析，自动检测时序路径，不会考虑电路的逻辑功能，因此无法判断电路逻辑功能经过的路线和非逻辑功能经过的路线）得到。两种验证手段相辅相成，确保验证工作高效、可靠地完成（Formality为纯逻辑验证，不包含物理和timing信息，因此需要STA工具的配合）。因此目前动态后仿真在大多数情况下已经不需要再进行，由STA + Formality进行替代。由于STA + Formality原理完全基于数学计算，不需要任何输出pattern，因此可以轻易实现电路path全覆盖。</p><p>其实动态后仿真并不是完全被替代，只能采用该方案可能会消耗过多时间，因此设计人员会采用STA + Formality，但该种方法也存在其缺点。由于<strong>STA只检查边沿timing，而Formality只看Register和Combination的抽象功能</strong>。动态后仿真再如下三种场景中是必要的：</p><ul><li>异步逻辑设计部分</li><li>ATPG向量验证</li><li>初始化状态验证</li></ul><p>除此之外，动态后仿真产生的VCD文件还可以做功耗分析。</p><p>因此，目前设计师采取了折中的策略：采用Formality保证门级网表在逻辑功能上与RTL设计保持一致，配合静态时序分析工具保证门级网表的时序正确，对于全同步的设计，甚至可以不做门级仿真；在面对异步设计和初始化等应用时，只需要针对该部分电路模块进行较少的动态后仿真工作，由此加快设计进度。</p><font color="red">! 与DC相比，PT分析的更快，需要的内存更少，且报告的信息量更多。更准确，包括一个较为特殊的功能Bottleneck Analysis -- 提取violation的path中共同的cell指令：</font><p>​                                                            <strong><em>report_bottleneck</em></strong></p><h1 id="验证步骤"><a href="#验证步骤" class="headerlink" title="验证步骤"></a>验证步骤</h1><ul><li>Load reference design and implementation netlist</li><li>match compare points</li><li>verify</li></ul><h1 id="测试详情"><a href="#测试详情" class="headerlink" title="测试详情"></a>测试详情</h1><p>Formality是一个基于数学意义的验证方法，通过比较设计A、B，当A的逻辑功能被B包含，则形式验证认为是通过的。注意并不需要两个设计完全相等，而是逻辑上具有包含的关系，此外Formality的目标是验证电路综合后的逻辑功能是否有所改变，因此在形式验证时有可能在Verify步骤中检查出部分compare point不对应的情况，这时应根据具体设计检查该部分compare point是否与设计的逻辑功能无关，再进行后续逻辑功能对比。</p><p><a href="https://mp.weixin.qq.com/s/XznSbJBlAdZvtAIpyzajAA">https://mp.weixin.qq.com/s/XznSbJBlAdZvtAIpyzajAA</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Formality </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go</title>
      <link href="/2022/06/28/Go/"/>
      <url>/2022/06/28/Go/</url>
      
        <content type="html"><![CDATA[<p>本文简要介绍了学习Golang的流程，并对Golang的主要基础知识进行了梳理。</p><span id="more"></span><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>许多文本编辑器都可以配置为保存文件时自动执行$gofmt$，这样源代码总会被恰当的格式化。</p><p>相关工具：$goimports$ —— 可以根据代码需要，自动的添加或删除$import$声明。</p><p>该工具并没有包含在标准的分发包中，可以用下面的命令安装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get golong.org/x/tools/cmd/goimports</span><br></pre></td></tr></table></figure><p>使用$VScode$安装$Go$相关插件时，部分插件会因为未设置代理等原因在$VScode$上无法成功部署，提示下载失败</p><p>解决方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启代理设置 Go 1.13以上版本默认启用</span></span><br><span class="line"><span class="keyword">go</span> env -w GO111MODULE=on</span><br><span class="line"><span class="comment">// 设置代理</span></span><br><span class="line"><span class="keyword">go</span> env -w GOPROXY= https:<span class="comment">//goproxy.io.direct</span></span><br></pre></td></tr></table></figure><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><strong>简短变量声明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B := 123</span><br></pre></td></tr></table></figure><p>该种类型的短变量声明必须使用在函数体内部，而不能用在包变量(根据赋予的初始值 自动定义变量类型)</p><p>该声明左边的变量可能并不是全为新声明变量，若一些已经在相同的语法域中声明过了，则该声明语句对已声明过的变量则只有赋值行为而没有声明效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out, err := os.Create(outfile)</span><br></pre></td></tr></table></figure><font color="red">err在该句中仅有赋值操作</font><ul><li>在同级语法域下，声明语句中必须至少要声明一个新的变量，否则无法编译通过</li><li>若该变量已经在外部语法域中声明，则简短变量声明语句将会在当前词发域重新声明一个新的变量</li></ul><p><strong>显示声明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var s string(or var s string = &quot;&quot;)</span><br></pre></td></tr></table></figure><p>该种声明变量后会自动给变量赋予其类型的初始值  —— 数值类型对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或应用类型（包括slice、指针、channel、函数）变量对应的零值是nil（实际内置为NULL）。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p><p>该种声明主要为突出变量的类型，通常用于变量类型和初始值不一致的情况</p><p>var s= “” 也属于显式声明，根据赋予的初始值自动赋予其变量类型</p><p>在Go语言中涉及到输出的时候，需要导入fmt包，由编译器对代码进行格式化</p><p>如使用输出的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(test_String[1:])</span><br></pre></td></tr></table></figure><p>Println使用的是fmt包中的函数</p><p>当在函数局部对一全局变量进行同名的声明时，该局部变量实际上为一新变量（尽管和全局变量同名）—— 这时全局变量会暂时“隐藏”</p><p>在局部变量释放后重新出现，不会受到局部赋值影响</p><p>而若在函数局部对全局变量赋值，则会改变改变量的值（注意：若在该函数内再调用次级函数，且次级函数会调用到该变量时，次级函数实际调用的是全局变量，而不是再第一级函数内声明产生的临时变量）</p><h3 id="作用域范围"><a href="#作用域范围" class="headerlink" title="作用域范围"></a><font color="red">作用域范围</font></h3><ul><li>全局变量能被各级函数作用域调用</li><li>次级函数作用域内声明产生的临时变量并不能被次-次级函数作用域访问</li><li>匿名函数作用域与其存在的函数相同</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    b := <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    f2()</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域与声明周期"><a href="#作用域与声明周期" class="headerlink" title="作用域与声明周期"></a><strong>作用域与声明周期</strong></h3><p>描述对象不同：</p><ul><li>作用域        声明语句</li><li>声明周期    变量</li></ul><p>作用不同：</p><ul><li>作用域        表示源代码的文本区域，是编译属性</li><li>生命周期    指程序存在的有效时间段，该时间内可以被程序其他部分引用，是程序运行时候的概念</li></ul><h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a><strong>内存释放</strong></h3><p>Go编译器会做逃逸分析，分析局部变量的作用域是否逃出了函数的作用域，若逃出则将变量放到堆上，未逃出则放到栈上（在函数中使用fmt.Println和Println的区别），这在使用指针时很重要</p><p>在slice和array上也会存在内存释放问题，当函数参数需要一个大数组中的部分数据时，即使通过切片减小了函数复制数据所需消耗的资源，但由于切片引用的数据仍属于该数组，所以数组还会存在内存中，由此造成资源的浪费</p><p>最好的解决办法是通过copy将目标切片复制到基于另一数组的切片中，使原数组被垃圾回收</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><p>在Go语言中，所有函数的参数都是拷贝传入的，函数参数将不再是函数调用时的原始变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名（输入参数）返回值类型</span>&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拥有函数名的函数只能在包级语法块中被声明</p><p>实际上普通有命名的函数也可以轻易的在自己的函数体中调用本身进行迭代</p><p>不过，通常会有if判断语句或for循环等进行判断执行，要避免出现无线迭代的情况</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h3><p>在Go语言中，指针不能指向常量或字面量（例：const变量）</p><p>也不能进行经常导致C语言内存泄漏继而程序崩溃的指针运算（如：pointer + 2, 移动指针指向字符串的字节数或数组的某个位置） — 保证了内存安全（类似Java中的应用）</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h3><p>匿名函数的实现依赖于函数字面量，可以在任意表达式中表示一个函数值</p><p>函数字面量的语法和函数声明相似（func后没有函数名）</p><p>其实际上是一种表达式，值被称为匿名函数（*在函数中定义的内部函数也可以引用该函数的变量）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test_funcliteral <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">test_funcliteral = <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test_funcliteral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上半部代码，该函数的返回值为另一个类型为func() int 的函数</p><p>如下半部代码，当匿名函数需要被递归调用时，必须先声明一个变量，再将匿名函数赋值给这个变量，通过分两步将函数字面量与拟定的变量名绑定</p><p>匿名函数也可称为闭包（函数式语言的术语）</p><p>**匿名函数（闭包）保存并积累其（匿名函数）中的变量（闭包中调用到的变量可能在外部定义）</p><font color="red">不管外部函数退出与否</font>，匿名函数都能继续操作外部函数中的局部变量！这里能调用的变量实际上是<font color="red">定义匿名函数的作用域内的变量（该闭包在main中定义，则能直接访问并‘保存’main中的变量，其他类型函数同理）</font> -- 并不是所有外部变量都能够直接调用（需要正常情况下能够访问到的变量）### **迭代**注意使用range和for进行迭代时。循环变量是在循环块作用域内进行声明，且循环变量是在同一块地址上进行值得迭代，所有有时需要在循环内部新建一个局部变量进行数据保留，以免数据丢失该问题常出现在匿名函数中，这是因为匿名函数记录得是循环变量的内存地址而不是其某一时刻的具体值<font color="red">所以在range或for循环下执行一个匿名函数时（且循环声明部分的循环迭代值会在匿名函数体中使用时）通常需要将该变量作为匿名函数的输入，由此进行数据的copy保存，避免由于迭代造成数据丢失，**错误**写法如下</font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">thumbnail.ImageFile(f) <span class="comment">//<span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码块中变量f是被所有的匿名函数值所共享，且会被连续的循环迭代所更新</p><p>当新的Goroutine开始执行字面函数时，for循环可能已经更新了f并且开始新的一轮迭代或（更有可能的）已经结束了整个循环，所以当这些Goroutine开始读取f的值时，它们所看到的值已经是slice的最后一个元素了。显示地添加这个参数，能够确保调用f所使用地数值是当go语句执行时“当前”的那个迭代变量数值</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p>在Go中，可以为数值、字符串、slice、map定义附加行为，即在同一个包内的任意命名类型定义方法，只要其底层类型不是指针或interface</p><p>（<em>不管method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换，但也要注意对函数调用时参数的复制安全问题，比如复制指针，但其调用的仍然是同一个底层数据）</em></p><p>是否使用指针要考虑对象是否很大，以及如果声明为非指针变量，则调用会产生一次拷贝</p><p><a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-04-func-method-interface.html">https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-04-func-method-interface.html</a></p><p>具体实现类似于将函数的第一个参数（和该方法对象有关）移到函数名前，则表明该对象具备该方法</p><p>同时每种类型及其方法的定义必须在同一个包中，因此无法对int等类型的对象定义方法</p><p>Go语言不支持传统面向对象中的继承特性，但可以通过在<font color="red">结构体内置匿名的成员来实现继承</font>（由此不仅可以继承匿名成员的内部成员，也可以继承其对应的方法）但这样所有继承来的方法的接收者参数依然是匿名函数成员本省 而不是当前的变量 — 由此无法实现C++中虚函数的多态特性</p><p>Go语言中方法是编译时静态绑定的，this就是实现该方法的类型的对象，如果需要虚函数的多态特性，则需要借助Go语言接口来实现(也支持继承后对方法的改写)</p><p>**别名类型没有原始类型上已经定义过的方法（别名类型即对原有类型的重新定义）</p><p>接收者（对方法而言）不能是一个指针类型，但是它可以是任何其他运行类型的指针</p><p><em>**</em>作用于变量上的方法（在调用时）实际上是不区分变量到底是指针还是实际值（编译器会完成从指针到值得引用和解引用）</p><p>但是 当设计到接口时问题就不同了</p><p>接口变量中存储得具体值是不可寻址得—&gt;<font color="red">不能从值到指针 但可以从指针到值</font></p><p>因此在涉及到接口时，需要严格区分Appender（接收器）得具体方法（Append）定义在指针还是值上 —&gt;在指针上时，编译器可以通过指针解引用找到对应类型得指针接收器和值接收器(所有方法)；而在值上，则只能找到值接收器得方法（部分方法）</p><font color="red">**总结**</font><p>在接口上调用方法时，必须有和方法定义时相同得接收者类型或者是可以从具体类型P直接进行辨识：</p><ul><li>指针方法可以通过指针对象调用</li><li>值方法可以通过值对象调用</li><li>接收者是值的方法可以通过指针对象调用，因为指针会首先被解引用</li><li>接收者是指针的方法不能通过值对象调用，因为存储在接口中的值没有地址</li></ul><p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值对象上被调用，因此不正确的赋值在编译期就会失败</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a><font color="red">接口</font></h3><p>接口中的多态：</p><p><a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.1.md">https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.1.md</a></p><font color="red">(结构体内嵌接口，可以假设该struct就是interface的一个实现，而不管struct是否已经实现interface所定义的函数)</font><p><strong><em>当一个类型为接口中的所有方法提供定义时，则称该类型实现了该接口</em></strong></p><p>在Go中接口和对象之间的转换非常灵活，可以轻易的进行隐式转换，所以有时需要新定义一个特殊方法用以区分接口</p><p>正如struct类型可以包含一个匿名字段，interface也可以嵌套另外一个接口</p><p>如果inter1作为inter2的一个嵌入字段，则inter2隐式地包含了inter1里面的method</p><p>有些新的接口类型通过组合已有的接口来定义（内含的接口都为单方法实现的接口）该语法和结构内嵌相似，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过考虑数据类型之间相同功能来创建抽象概念，而不是类型的相同数字字段</p><p>Interface{}的值不是任意类型，其类型就是其本身</p><p>接口包含两个字的大小，类似于（type, value）</p><p><strong>指针类型可以调用其指向的值的方法，但值方法不能调用指向其本身的指针的方法（Golang所有传递都是值传递的特性造成的）</strong></p><p>静态类型就是变量声明时的类型，不会随着程序编译而进行变化</p><p>动态类型则可看作是变量的“实时类型”，所以定义变量可以按如下所示：</p><script type="math/tex; mode=display">age := (int)(25)        //或者使用age := (interface{})(25)</script><p><em>动态类型是程序运行时系统才能看见的类型</em></p><p>接口根据是否有具体的方法可以分为iface和eface 分别表示有方法的接口和无方法的接口</p><p><img src="/2022/06/28/Go/1.png" alt="1"></p><p><img src="/2022/06/28/Go/2.png" alt="2"></p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="错误声明"><a href="#错误声明" class="headerlink" title="错误声明"></a>错误声明</h3><p>一般使用os库中的Stderr方法配合Fprintf进行错误流的报告，使用表示任意类型默认格式值的动词%v，向标准错误流打印一条信息(nil内置值等于NULL)，err的值为nil时表示操作无误。</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>使用bufio包中的Newscanner方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA Routing Architecture Between Tiles</title>
      <link href="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/"/>
      <url>/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/</url>
      
        <content type="html"><![CDATA[<p>本文简要分析了$FPGA$架构间的路由结构，介绍了几种经典的$SwitchBlock$结构和$ConnectionBlock$结构，在此基础上提供了一种可重复布局的$fabric$路由架构。</p><span id="more"></span><h1 id="基本结构-—-Island"><a href="#基本结构-—-Island" class="headerlink" title="基本结构 — $Island$"></a>基本结构 — $Island$</h1><h2 id="Switch-Block"><a href="#Switch-Block" class="headerlink" title="$Switch Block$"></a>$Switch Block$</h2><p>目前通用的几种交换块结构为：$Universal, Disjoint, Wil$</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/SwitchBlock.PNG" alt="SwitchBlock"></p><p>$Disjoint$类型会导致路由线路被限制在同一类型轨道内，如在该图中0通道输入仅能连接到0轨道输出，因此任何由$CLB$导入0轨道的信号都不能通过其他轨道路由，而$Universal$和$Wilton$型则属于全连接类型，且其$Top$结构仅需更少的布线轨道和晶体管来实现。</p><h2 id="描述参数"><a href="#描述参数" class="headerlink" title="描述参数"></a>描述参数</h2><ul><li>$k$      $LUT$输入    $3 to 7 inputs$</li><li>$N$      $Cluster$ 中 $LUT$ 数量    $1 to 10 LUTs$</li><li>$I$      $CLB$输入    $4 to 40 inputs$</li><li>$W $    通道宽度，表示每个通道中的track数    $10 to 60 tracks$</li><li>$F_s$    交换块灵活度$(Flexibility of Swtich Block)$    表示发生在开关块中轨道上的可编程连接的数量</li><li>$F_{c_{in}}$    连接块灵活度$(Flexibility of ConnectionBlock)$表示$CLB$ 输入可连接的轨道数与总轨道数之比    $0.1 to 1.0$</li><li>$F_{c_{out}} $   连接块灵活度$(Flexibility of ConnectionBlock)$表示$CLB$ 输出可连接的轨道数与总轨道数之比    $0.1 to 1.0$</li></ul><h2 id="物理层部署"><a href="#物理层部署" class="headerlink" title="物理层部署"></a>物理层部署</h2><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/physical layer.PNG" alt="physical layer"></p><p>对于$F_s = 3$的交换块，其任意输入都有三个潜在的连接对象；同理，任意输出都有三个潜在的输入连接对象。因此如左图所示的交换快Top结构可具体为右图中的多路选择器，其晶体管级实现根据具体情况决定。</p><h1 id="TOP-实现"><a href="#TOP-实现" class="headerlink" title="$TOP$实现"></a>$TOP$实现</h1><h2 id="Single-Drive-Routing"><a href="#Single-Drive-Routing" class="headerlink" title="$Single Drive Routing$"></a><a href="https://www.eecg.utoronto.ca/~jayar/pubs/luu/luufpga09.pdf">$Single Drive Routing$</a></h2><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/1.PNG" alt="1"></p><p>在$Single Drive Routing$结构中，可编程性是通过在驱动器的输入上使用多路复用器来实现的，每个布线轨道都只有一个物理驱动器，这种对单个驱动器的限制意味着逻辑块输出只能连接到其驱动器与逻辑块相邻的布线轨道，以避免与相邻逻辑集群的布线过长。典型的单驱动器布线架构将驱动器放置在布线的一端而不是中间，每根线只能在特定方向发送信号。</p><p>目前，<a href="http://www.altera.com/literature/hb/ stratix-iv/stratix4_handbook.pdf">$Altera$</a>及<a href="http://www.altera.com/literature/hb/ stratix-iv/stratix4_handbook.pdf">$Xilinx$</a>最近推出的所有$FPGA$设备都特定使用单驱动器路由架构。</p><h2 id="基于定长路由线-tile-的-fabric-生成"><a href="#基于定长路由线-tile-的-fabric-生成" class="headerlink" title="基于定长路由线$tile$的$fabric$生成"></a><a href="https://www.eecg.utoronto.ca/~vaughn/papers/fpga2000.pdf">基于定长路由线$tile$的$fabric$生成</a></h2><p>通常构建$fabric$需要根据每个$tile$的具体连接情况单独指定其开关块和连接块。如果只是简单的对每个$tile$进行路由通路复制，则会出现如下图所示的问题——部分$CLB$输出引脚无法通过路由轨道驱动部分其他$CLB$的输入引脚：</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/ReplicationgChannel.PNG" alt="ReplicationgChannel"></p><p>造成该问题的原因，是在$Routing$中采用的$Segment$无法在中端加入开关——否则实际布线时就会编程两根较短导线，而单纯的重复相同$tile$的布局无法针对该路由结构的情况进行针对性调整。</p><p>可通过规律性调整路由线起点解决该问题。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/Adjust_before.PNG" alt="Adjust_before"></p><p>如上图所示的$fabric$结构，将每个tile对应的水平路由轨道从下到上分别命名为$Channel0-2$，垂直路由轨道从左到右分别命名为$Channel0-2$；首先考虑水平$Channel$，对于轨道0中$track0$线段的左端与满足如下条件的逻辑块对齐：</p><script type="math/tex; mode=display">(i + 2) module 3 = 0</script><p>其中$ i $是逻辑块的水平(x)坐标。则对于轨道1中$track0$线段的左端与满足如下条件的逻辑块对齐：</p><script type="math/tex; mode=display">(i + 3) module3 = 0</script><p>对于其他编号的$track$的起点则要求顺序后移——随$Channel$编号增加方向；</p><p>垂直方向通道判断$Segment$起点方法公式与水平通道相同(编号规则不改变)，且执行类似的起点后移——通道$i+1$中每个$Segment$起点相对于通道i中的起点向后移动一个$CLB$。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/Adjust_after.PNG" alt="Adjust_after"></p><p>再更改其$Top$结构，使其每个$Tile$路由结构相同，便于复制生成目标大小的$fabric$。</p><h1 id="Detailed-Routing-Architecture"><a href="#Detailed-Routing-Architecture" class="headerlink" title="$Detailed Routing Architecture$"></a><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1067.891&amp;rep=rep1&amp;type=pdf">$Detailed Routing Architecture$</a></h1><p>影响FPGA整体性能的一个主要因素是路由开关的选择，路由开关可由输入复用传输晶体管、缓冲器和输出解复用晶体管的任意组合进行建模。其组合中在电气上可行的5中结构如下表所示：</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/DirectDriveMux.PNG" alt="DirectDriveMux"></p><ul><li>缓冲器</li><li>缓冲器和输出传输晶体管</li><li>传输晶体管</li><li>直接驱动多路复用器</li><li>带缓冲器的传输晶体管多路复用器和输出多路复用器</li></ul><p>缓冲器没有任何执行可编程路由的能力，但可能部署在架构中的不同位置以重新为信号供电。</p><p>在本论文中，尝试使用不同线长占比的$Routing$结构对同一基准电路进行布线，并检测其消耗资源情况，如下图显示对包含$50\%Segment$长度4和$50\%Segment$长度16，以及$50\%Segment$长度4和$50\%Segment$长度8两种布线结构使用直接驱动$(Direct Routing)$的效果。其基本架构在两种布线结构中都使用了$50\%$的传输晶体管和$50\%$的缓冲开关。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/fraction direct routing.PNG" alt="fraction direct routing"></p><center>Average critical path delay for varying fraction of direct-drive routing wires</center><p>在实验中，$fabric$路由面积随着直接驱动开关的使用而单调减小。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/Channel Width Required for varying fraction of DDW.PNG" alt="Channel Width Required for varying fraction of DDW"></p><center>Channel Width required for varing fraction of direct-drive wires</center><p>$4/8$架构所需的通道宽度大致恒定，而由于单个驱动点对$Segement$为16的导线形成了更严格的布线约束，因此$4/16$架构对应的通道宽度有所增加。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/Total Routing Area.PNG" alt="Total Routing Area"></p><center>Total routing area required for varying fraction of direct-drive wires</center><p>尽管$4/8$结构导致通道宽度增加，但总布线面积回随着布线多路复用器输入上的小晶体管替换宽布线晶体管而减少。因此如上图所示，在两种现场组合中的任何一种中，$100\%$直接驱动多路复用器都会形成速度最快和面积最小的$fabric$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xilinx的RAM使用</title>
      <link href="/2022/05/09/Xilinx%E7%9A%84RAM%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/09/Xilinx%E7%9A%84RAM%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文简要介绍了$Vivado$中常用的各种$RAM$类型</p><span id="more"></span><h1 id="RAM类型"><a href="#RAM类型" class="headerlink" title="RAM类型"></a>RAM类型</h1><p>单端RAM —— Single Port RAM</p><p>伪双端RAM —— Sinple Dual Port RAM</p><p>真双端RAM —— True Dual Port RAM</p><h1 id="接口区别"><a href="#接口区别" class="headerlink" title="接口区别"></a>接口区别</h1><p><img src="/2022/05/09/Xilinx%E7%9A%84RAM%E4%BD%BF%E7%94%A8/1.PNG" alt="1"></p><p>单端口：具备一套地址总线，仅通过一个端口对存储进行读写访问；读写无法同时进行。</p><p>伪双端口：具备两套地址总线，提供两个端口（A、B），但每个端口仅负责一项功能，如通过A端口进行写访问，通过B端口进行读访问；读写可并行执行。</p><p>真双端口：具备两套地址总线，提供两个端口（A、B），且每个端口均可负责读写功能；双端口读写均可并行执行。</p><p>————————————————————同时进行读写时 不能对同一地址进行操作 不管何种类型RAM 实际内部都是同一块地址Mem（在FPGA中实现时的资源消耗量也可看出）———————————————————-</p><p>综上：对于双端口RAM，在外部控制时若只将A端口用作写、B端口用作读，则实际实现和伪双端口RAM相同；</p><p>双端口ROM和双端口RAM相同，可实现两个端口同时读取ROM中的数据，所以当两个Processor同时访问同一数据时，就不需要例化两个相同的ROM浪费资源。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Xilinx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vivado的Debug实现方法</title>
      <link href="/2022/05/09/Vivado%E7%9A%84Debug%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2022/05/09/Vivado%E7%9A%84Debug%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本文简要介绍了$Xilinx Vivado$软件中通用的电路$Debug$方法。</p><span id="more"></span><h1 id="一-例化ILA-IP核"><a href="#一-例化ILA-IP核" class="headerlink" title="一 例化ILA IP核"></a>一 例化ILA IP核</h1><p>​    通过IP核配置的方法配置检测信号，主要包括数据：信号数量、位宽、激发方式（一般通过Data And方式激活）—— 该操作是在综合前通过添加IP在原本电路设计中增加额外的Debug电路来实现纠错。</p><h1 id="二-代码标记"><a href="#二-代码标记" class="headerlink" title="二 代码标记"></a>二 代码标记</h1><p>​    通过在代码中对信号直接标记的方法添加Debug，在综合后通过 set up debug 选项实现Debug模块的添加，具体流程如下“网表标记”所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* Mark_debug = &quot;TRUE&quot; *)regsignal_A;</span><br></pre></td></tr></table></figure><h1 id="三-通过网表标记"><a href="#三-通过网表标记" class="headerlink" title="三 通过网表标记"></a>三 通过网表标记</h1><p>​    该操作需要在综合后在网表中设置Mark Debug（或在综合后的电路原理图中）；</p><p>​    在标记Debug后，就等于选择了需要Debug的信号，之后再综合设置中设置Debug参数。</p><p><img src="/2022/05/09/Vivado%E7%9A%84Debug%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/2.PNG" alt="2"></p><p>*该方法无法对所有信号实现Debug，例如模块的直接输入信号就无法添加Mark Debug（可通过添加Buffer模块实现添加）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vivado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog的分层事件队列</title>
      <link href="/2022/05/09/Verilog%E7%9A%84%E5%88%86%E5%B1%82%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/"/>
      <url>/2022/05/09/Verilog%E7%9A%84%E5%88%86%E5%B1%82%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>本文从仿真器的角度出发，借助Verilog中分层事件队列对阻塞和非阻塞赋值进行考量，并分析其特点。</p><span id="more"></span><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>仿真器首先按照仿真时间对事件进行排序，然后再在当前仿真时间里按照事件的优先级顺序进行排序。</p><p>活跃事件是优先级最高的时间，在活跃事件之间，它们的执行顺序是随机的。</p><p>两个缩写：$RHS(right-hand-side)$和$LHS(left-hand-side)$。</p><p>前者指等式右边的表达式或者变量$(RHS expression or RHS variable)$，后者指等式左边的表达式或者变量$(LHS expression or LHS variable)$。</p><p>由上表可知，阻塞赋值属于活跃事件，会立刻执行，这就是阻塞赋值<em>计算完毕，立即更新</em>的原因。此外，由于在分层事件队列中，只有将活跃事件中排在前面的事件调出，并执行完毕后，才能够执行下面的事件，这就可以解释阻塞赋值的第二个特点。</p><p>同样由上表可知，非阻塞赋值的$RHS$计算属于活跃事件，而非阻塞赋值的更新事件排在非活跃事件之后，因此只有仿真队列中所有的活跃事件和非活跃事件都执行完毕后，才轮到非阻塞赋值更新事件，这就是非阻塞赋值必须分两拍完成的原因。</p><h2 id="阻塞赋值特点："><a href="#阻塞赋值特点：" class="headerlink" title="阻塞赋值特点："></a><strong>阻塞赋值特点：</strong></h2><ul><li><p>$RHS$的表达式计算和$LHS$的赋值更新，这两个动作之间不能插入其他动作，即所谓计算完毕，立即更新。</p></li><li><p>所谓阻塞赋值就是在一个begin…end块中的多个阻塞赋值语句，只有上一句完全执行完毕后，才会执行下一语句。</p></li></ul><h2 id="非阻塞赋值程序的执行："><a href="#非阻塞赋值程序的执行：" class="headerlink" title="非阻塞赋值程序的执行："></a><strong>非阻塞赋值程序的执行：</strong></h2><p>非阻塞赋值，$RHS$的计算表达式和$LHS$的赋值更新分两个节拍执行。首先，应该是$RHS$表达式计算，得到新值后并不立即赋值，而是放在事件队列中等待，直到当前仿真时刻的后期才执行。</p><h1 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h1><p><img src="/2022/05/09/Verilog%E7%9A%84%E5%88%86%E5%B1%82%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/微信图片_20220627200539.jpg" alt="微信图片_20220627200539"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨时钟域处理方案</title>
      <link href="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/"/>
      <url>/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了跨时钟域场景中亚稳态出现的原因，以及设计中常用的减少信号出现亚稳态的主要方法。</p><span id="more"></span><p><strong><em>Clock Domain Crossing Solution</em></strong></p><p><a href="http://www.sunburst-design.com/papers/CummingsSNUG2008Boston_CDC.pdf">本文参考文章A</a></p><p><a href="https://www.cnblogs.com/lyc-seu/p/12441366.html">本文参考文章B</a></p><h1 id="异步时序定义"><a href="#异步时序定义" class="headerlink" title="异步时序定义"></a>异步时序定义</h1><p>异步时序设计指的是在设计中有两个或以上的时钟， 且时钟之间是同频不同相或不同频率的关系。而异步时序设计的关键就是把数据或控制信号正确地进行跨时钟域传输。</p><h1 id="亚稳态"><a href="#亚稳态" class="headerlink" title="亚稳态"></a>亚稳态</h1><p>触发器具备其规定的建立$(setup)$和保持$(hold)$时间，在该时间参数内，输入信号在时钟的上升沿期间不能改变，否则会导致采集信号结果不可预知，即亚稳态。</p><p>亚稳态是指在设计的正常运行阶段的某个时间点，在一段时间内呈现不稳定的0或1状态的信号。</p><p>在多时钟设计中，无法避免亚稳态，但可以采取策略抵消亚稳态的不利影响。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220510233046580.png" alt="image-20220510233046580"></p><center>异步时钟的同步失败</center><h2 id="亚稳态潜在问题"><a href="#亚稳态潜在问题" class="headerlink" title="亚稳态潜在问题"></a>亚稳态潜在问题</h2><p>如下图所示，当A时钟域输出信号经B时钟域采集变为亚稳态时，有可能导致该非法信号值在整个设计的其余部分中传播。</p><p>由于CDC信号会在一段时间内波动，因此接收时钟域中的输入逻辑可能会将波动信号的逻辑电平识别为不同的值，从而将错误信号传播到接收时钟域。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220514160247992.png" alt="image-20220514160247992"></p><center>亚稳态 bdat1 信号在后续整个设计中传播无效数据</center><p>任何设计中使用的触发器都有一个指定的建立和保持时间 —— 在时钟上升沿之前和之后不允许合法的改变数据输入的时间。该事件窗口被精确的指定为设计参数，以防止数据信号在太接近另一个同步信号时变化，进而导致输出信号进入亚稳态。</p><h1 id="同步器设计"><a href="#同步器设计" class="headerlink" title="同步器设计"></a>同步器设计</h1><p>跨时钟域传递信号，面临的第一个重要问题是，是否需要对一个时钟域传递到另一个时钟域信号的每个值进行采样？</p><h2 id="两种同步场景"><a href="#两种同步场景" class="headerlink" title="两种同步场景"></a>两种同步场景</h2><p>跨越CDC边界传递信号时可能出现两种情况：</p><ul><li>允许错失部分跨时钟域信号</li><li>必须对跨时钟域传递的每个信号进行采样</li></ul><p><strong>情况一：</strong>尽管不需对信号每个值均进行采样，但采样值的准确度依然很重要。例如标准异步FIFO设计中使用的格雷码计数器。在正确设计的异步FIFO模型中，同步格雷码计数器无需从相反的时钟域捕获每个合法信号，对模型更重要的是采样值能够准确识别何时发生了满和空的情况。</p><p><strong>情况二：</strong>在允许对CDC信号进行变化前，必须正确识别和确认CDC信号。</p><h2 id="两级触发同步器"><a href="#两级触发同步器" class="headerlink" title="两级触发同步器"></a>两级触发同步器</h2><blockquote><p>同步器是一种对异步信号进行采样并输出具有与采样时钟同步的转换后的信号的设备</p></blockquote><p>数字设计人员使用的最简单和最常见的同步器是两级触发同步器，如下图所示。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220514162011456.png" alt="image-20220514162011456"></p><center>两级触发同步器</center><p>第一个触发器将异步输入信号采样到新的时钟域并等待一个完整的时钟周期以允许任何亚稳态在第一阶段输出信号衰减，然后第一阶段信号以相同的时钟被采样到第二阶段触发器，使第二阶段输出信号为一个已经同步的稳定且有效的信号，并准备在新的时钟域内进行分发。</p><p>理论上，当信号被采样到第二级触发器时，第一级触发器输出的亚稳态信号仍够使第二级触发器的输出信号也进入亚稳态，该点可由同步故障间隔事件（MTBF）的计算解释。</p><p>对于大多数同步应用，两级触发同步器已经足以消除所有可能存在的亚稳态。</p><h2 id="MTBF-—-信号错误平均时间"><a href="#MTBF-—-信号错误平均时间" class="headerlink" title="MTBF — 信号错误平均时间"></a>MTBF — 信号错误平均时间</h2><font color="red">（版本1）</font><p>触发器进入亚稳态的时间可以用参数$MTBF(Mean Time Between Failures)$来描述。</p><p>这是因为故障意味着传递到同步触发器的信号在第一级同步器触发器上已经进入亚稳态，并在一个周期后被第二级触发器以相同时钟进行采样后的输出信号仍然是亚稳态。由于信号在一个时钟周期后没有稳定到已知值，从而导致相应逻辑的潜在故障。</p><p>通常，较大的MTBF数字表示潜在故障之间间隔时间较长，而较小的数字则表示亚稳态可能经常发生，这同样会导致设计中的故障。</p><p>影响同步器电路MTBF的两个最重要的参数分别是采样时钟频率（信号被采样到接收时钟域的速度）和数据改变频率（跨越CDC边界的数据更改速度有多快），其公式如下所示：</p><script type="math/tex; mode=display">MTBF = 1 / {f_{clk} * f_{data} * X}</script><p>$f_{clk}$      同步时钟频率</p><p>$f_{data}$    数据变化频率</p><p>$X$         其他参数</p><p>由公式分析可知，在更高速度的设计中，或当采样数据更频繁地变化时，故障发生地频率会更高 — MTBF数值更小。</p><font color="red">（版本2）</font><p>即触发器采样失败的时间间隔，其公式如下所示：</p><script type="math/tex; mode=display">MTBF=e^ {t_r/\tau} / T_0fa</script><p>其中：</p><ul><li>$t_r$  分辨时间 (时钟沿开始)</li><li>$\tau, T_0   $ 触发器参数</li><li>$f  $  采样时钟频率</li><li>$a  $  异步事件触发频率</li></ul><p>通常，MTBF越大说明系统采样失败的可能性越小。因此，对于高速设计，MTBF更容易发生。对于一个典型的0.25um工艺的ASIC库中的一个触发器，我们取如下参数：</p><script type="math/tex; mode=display">t_r=2.3ns, \tau=0.31ns, T_0= 9.6as, f=100MH_Z, a=10MH_Z, MTBF = 2.01 days</script><p>即触发器以$100MH_Z$工作，假设异步时间触发的频率，也就是数据变化的频率与采样时钟的频率相同。使用$10MH_Z$频率进行采样，每个上升沿数据都会发生变化，由数据可知没两天就可能会采集到一次亚稳态。如果使用单锁存器同步，则采样时钟上升沿采集原始信号数据时很可能导致采集信号亚稳态。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/3.png" alt="3"></p><h2 id="三级触发同步器"><a href="#三级触发同步器" class="headerlink" title="三级触发同步器"></a>三级触发同步器</h2><p>对于一些非常告诉地设计，两级触发同步器地MTBF太小，因此添加了第三级触发器已使MTBF增加。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220514164001634.png" alt="image-20220514164001634" style="zoom:50%;"></p><center>高速设计中的三级触发同步器</center><h2 id="在发送时钟域同步信号"><a href="#在发送时钟域同步信号" class="headerlink" title="在发送时钟域同步信号"></a>在发送时钟域同步信号</h2><p><strong>CDC设计的常见问题：</strong>通常，在将目标CDC信号从源时钟域传递到目标时钟域前就应该在发送时钟域中将信号“注册”，下图展示了CDC信号在发送前未在发送时钟域注册会导致的问题。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220514164656601.png" alt="image-20220514164656601"></p><center>未注册信号跨越CDC边界</center><p>在该实例中，来自发送时钟域的组合输出可能会在CDC边界处经历组合稳定。这种组合稳定增加了数据变化频率，可能会产生较小的突发振荡数据，从而增加可能会被采样时钟误采的信号边沿，进而增加对变化数据边沿处采样并生成亚稳态信号的概率。</p><h2 id="信号同步到接收时钟域"><a href="#信号同步到接收时钟域" class="headerlink" title="信号同步到接收时钟域"></a>信号同步到接收时钟域</h2><p>发送时钟域中的信号在传递到CDC边界前应进行同步，该过程减少了在接收时钟域采样时潜在采样的边沿数量，有效降低了MTBF公式中的数据变化频率，从而增加了CDC信号错误间的时间（见MTBF概念描述）。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515141015090.png" alt="image-20220515141015090"></p><center>信号跨越CDC边界前经过寄存器规整</center><p>如上图所示，aclk输出信号在被传输到bclk时钟域前先在基于aclk的触发器上进行信号规整，adat触发器能够过滤掉A时钟域组合逻辑部分可能产生的逻辑信号不稳定，并将“干净”的信号传递到B时钟域。</p><h1 id="快速信号同步到慢时钟域"><a href="#快速信号同步到慢时钟域" class="headerlink" title="快速信号同步到慢时钟域"></a>快速信号同步到慢时钟域</h1><p>当CDC信号跨时钟域时必须保证每个数据均被有效采集，则在时钟域间传递时信号宽度或同步技术就非常重要。例如，发送时钟域信号可能会在接受时钟域采集后更改两次，或可能过于接近慢时钟域采样信号的边沿，需要对所有情况进行考虑，否则就无法保证发送域信号每位均被接收时钟域正确采集。</p><p>解决方案：</p><ul><li>开环解决方案，确保在没有确认的情况下捕获信号</li><li>闭环解决方案，需要确认收到跨越CDC边界的信号</li></ul><h2 id="时钟域间可靠信号传递的要求"><a href="#时钟域间可靠信号传递的要求" class="headerlink" title="时钟域间可靠信号传递的要求"></a>时钟域间可靠信号传递的要求</h2><p>当较快时钟域频率为较慢时钟域频率1.5倍及以上时，则较慢的发送信号同步到较快的接收时钟域通常不成问题 —— 较快的时钟域信号会对较慢CDC信号进行一次或多次采样，因此对该种情况的信号传递一般只需简单的两级触发同步器来实现单个CDC信号的时钟域跨越。</p><h3 id="“三边沿”要求"><a href="#“三边沿”要求" class="headerlink" title="“三边沿”要求"></a>“三边沿”要求</h3><p>Mark Litterick 指出，当通过两级触发同步器在时钟域间传递CDC信号时，信号宽度必须大于接收时钟域周期宽度的$1 - 1/2$ 倍。</p><blockquote><p>输入数据值必须在三个目标时钟边沿保持稳定</p></blockquote><p>对于特别长的源时钟和目标时钟频率，该要求可能会安全的放宽到接收时钟域周期时间的 $1 - 1/4$ 倍或更小，但是“三边沿”要求是最安全的初始设计条件，可以通过使用System Verilog 断言比在仿真期间动态测量CDC信号的分数宽度证明。“三边沿”要求实际上适用于开环和闭环解决方案，但闭环解决方案的实现会自动确保为所有CDC信号检测到至少三个信号边沿。</p><h2 id="传输快速CDC脉冲"><a href="#传输快速CDC脉冲" class="headerlink" title="传输快速CDC脉冲"></a>传输快速CDC脉冲</h2><p>对于发送时钟域频率高于接收时钟域的情况，且CDC信号在发送时钟域中只有一个周期宽度时，则CDC信号可能会在较慢时钟的上升沿间变成高电平和低电平（而不是仅有单个快时钟域周期宽度的“脉冲”信号）且不会被捕获到较慢时钟域中，如下图所示。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515144051932.png" alt="image-20220515144051932"></p><center>同步中的较短CDC“脉冲”信号的遗失</center><h2 id="采样较长CDC信号"><a href="#采样较长CDC信号" class="headerlink" title="采样较长CDC信号"></a>采样较长CDC信号</h2><p>当发送时钟域向接收时钟域发送一个略宽于接收时钟频率周期的信号的情况，如下图所示同样会导致缺陷的发生。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515144504362.png" alt="image-20220515144504362"></p><center>边缘CDC脉冲信号违反建立和保持时间</center><p>当CDC信号变化过于接近接收时钟域的两个上升时钟沿，就有可能导致信号第一个时钟沿的建立时间违例和第二个时钟沿的保持时间违例。</p><h2 id="开环解决方案-同步采样信号"><a href="#开环解决方案-同步采样信号" class="headerlink" title="开环解决方案 - 同步采样信号"></a>开环解决方案 - 同步采样信号</h2><p>如下图所示，一个潜在的解决方案是在超过采样时钟周期时间的一段时间内置位CDC信号。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515145630411.png" alt="image-20220515145630411"></p><center>延长信号以保证对控制信号进行采样</center><p>当相对时钟频率固定且分析正确时，可以使用开环采样方法。</p><ul><li>Advantages        开环解决方法是通过CDC边界传递信号的最快方式，无需确认接收信号</li><li>Disadvantages  开环解决方法并不是通用的解决方案，当设计要求发生变化，设计者可能无法对相应的开环设计方案做出调整或修改 —— 可通过向模型添加System Verilog断言来检测输入脉冲是否未能满足”三边沿“设计要求来降低出现该问题的可能性</li></ul><h2 id="闭环解决方案-同步采样信号"><a href="#闭环解决方案-同步采样信号" class="headerlink" title="闭环解决方案 - 同步采样信号"></a>闭环解决方案 - 同步采样信号</h2><p>另一种潜在解决方案是发送控制信号，将其同步到新的时钟域，再将同步信号通过另一同步器传递回发送时钟域作为确认信号。</p><ul><li>Advantages       同步反馈信号是一种非常安全的即使，可以确定控制信号已被识别并被采样到新的时钟域</li><li>Disadvantages  在允许控制信号改变前，同步控制信号可能存在相当大的延迟</li></ul><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515150747598.png" alt="image-20220515150747598"></p><center>通过带有反馈的信号以确认接收完成</center><h1 id="跨时钟域传递多信号"><a href="#跨时钟域传递多信号" class="headerlink" title="跨时钟域传递多信号"></a>跨时钟域传递多信号</h1><p>在时钟域间传递多信号时，简单的同步器并不能保证数据的安全。主要问题是在同步同一时钟域的多位信号时会遭遇小的数据变化偏移(Data Changing Skew)，这些偏移偶尔会导致待传输信号被接收时钟域中的不同时钟上升沿采样。即使能够完美掌控和匹配多位信号的走线长度，上升和下降时间的差异及芯片上的工艺变化也可能会引入足以引起问题的信号偏移，从而导致在其他走线上出现采样失败。</p><p>必须采用多位信号CDC策略来避免多位置的偏移采样。</p><h2 id="多位信号CDC策略"><a href="#多位信号CDC策略" class="headerlink" title="多位信号CDC策略"></a>多位信号CDC策略</h2><ul><li>多位信号合并    将多个CDC位合并为1位CDC信号</li><li>$Multi - Cycle Path$    使用同步加载信号安全的传递多个CDC位</li><li>使用格雷码传递多位CDC信号</li></ul><h2 id="多位信号合并"><a href="#多位信号合并" class="headerlink" title="多位信号合并"></a>多位信号合并</h2><p>该部分需要从设计的角度考量，有时并不需要多位跨时钟域信号，从功能上将控制信号消减至单比特。</p><h2 id="同时需要的两个重要控制信号"><a href="#同时需要的两个重要控制信号" class="headerlink" title="同时需要的两个重要控制信号"></a>同时需要的两个重要控制信号</h2><p>下图所示的示例中，接收时钟域中的寄存器需要加载信号和使能信号才能将数据值加载到寄存器中。当负载和使能信号都在相同的发送时钟边沿驱动，则控制信号间的小偏移可能会导致两个信号同步到接收时钟域内的不同时钟周期，进而导致数据失败。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515152738526.png" alt="image-20220515152738526"></p><center>跨时钟域传递多位控制信号</center><p>该问题可通过在设计上合并控制信号解决，如下图所示，仅从一个负载使能信号驱动接收时钟域中的负载和使能寄存器的输入吸纳后，由此可以消除两个控制信号在时钟上发生偏移的可能性。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515153136446.png" alt="image-20220515153136446"></p><center>跨越CDC边界前合并控制信号</center><h2 id="两端连续控制信号情形"><a href="#两端连续控制信号情形" class="headerlink" title="两端连续控制信号情形"></a>两端连续控制信号情形</h2><p>如下图所示，两使能信号 aen1 和 aen2 被连续的从发送时钟域驱动至接收时钟域以控制寄存器链的使能输入。问题是在发送时钟域中，aen1控制信号与aen2控制信号可能会有一段较小的间隙 —— 即aen1和aen2信号相与可能会出现一段较短的脉冲信号。而当接收时钟域采样信号的上升沿出现在该段间隙中时，就会导致在接收时钟域的使能控制信号链中形成一个周期间隙，进而导致后续的数据寄存器丢失数据。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515154236184.png" alt="image-20220515154236184"></p><center>跨时钟域发送连续控制信号的潜在问题</center><p>该问题可通过合并信号并加一级触发器解决，如下图所示。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515154359754.png" alt="image-20220515154359754"></p><center>在新时钟域中生成正确序列信号的逻辑电路</center><p>通过仅发送一个控制信号至接收时钟域，再在接收时钟域中生成第二个相移移位使能控制信号。</p><h2 id="多位CDC信号潜在问题"><a href="#多位CDC信号潜在问题" class="headerlink" title="多位CDC信号潜在问题"></a>多位CDC信号潜在问题</h2><p>下图显示了在时钟域间传递的两个编码控制信号。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515154926112.png" alt="image-20220515154926112"></p><center>多位编码控制信号的跨时钟域</center><p>若两个编码信号在采样时有轻微偏移，则可能会在接受时钟域的一个时钟周期内生成错误的解码输出。</p><p>Multi-Cycle Path (MCP) 公式 和FIFO 技术可用于解决和传递多位CDC信号相关问题。</p><ul><li>闭环 - 带反馈的 MCP 公式</li><li>闭环 - 带确认反馈的 MCP 公式</li><li>异步 FIFO 实现</li><li>2 - Deep FIFO实现</li></ul><h2 id="Multi-Cycle-Path-MCP"><a href="#Multi-Cycle-Path-MCP" class="headerlink" title="Multi - Cycle Path (MCP)"></a>Multi - Cycle Path (MCP)</h2><p>在安全传输多位CDC信号时，MCP公式是一种常用的策略。</p><p>MCP 公式是指将非同步数据发送到具备同步控制信号的接收时钟域。数据和控制信号同时发送，使得数据到达目标寄存器输入的同时，控制信号也到达目标寄存器的负载输入且已经同步了两个接收时钟周期。</p><p><strong>Advantages：</strong></p><ul><li>发送时钟域无需根据跨越的时钟计算合适的信号宽度</li><li>发送时钟域只需将一个使能切换到接收时钟域，以指示数据已通过并准备好加载。使能信号无需返回其初始逻辑电平</li></ul><p>该策略在不同步的情况下传递多个CDC信号，同时将同步的使能信号传递到接收时钟域。在同步使能通过同步到达接收寄存器之前，不允许接收时钟域对多位CDC信号进行采样。</p><p>这种策略被称为多周期路径公式，因为未同步的数据字直接传递到接收时钟域并保持多个接收时钟周期，由此在允许未同步的数据字改变前，允许使能信号同步并识别到接收时钟域中。</p><p>因为未同步的数据在被采样前经过多个时钟周期并保持问题，所以不会有采样值变为亚稳态的危险。</p><h3 id="使用同步使能脉冲信号的MCP公式"><a href="#使用同步使能脉冲信号的MCP公式" class="headerlink" title="使用同步使能脉冲信号的MCP公式"></a>使用同步使能脉冲信号的MCP公式</h3><p>在时钟域间传递同步使能信号最常用方法是切换使能信号，该信号被传递到同步脉冲发生器，以只是可以在下一个接收时钟沿捕获未同步的多周期数字。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515162323128.png" alt="image-20220515162323128"></p><center>同步脉冲信号生成逻辑</center><p>这种同步使能脉冲信号生成的一个关键特性是输入信号的极性无关紧要。如上图所示，d输入在周期1中切换为高电平，到周期4，高电平信号已通过三个同步触发器传播，在周期3中，q2和q3触发器的输出具有不同的极性，导致该周期中异或门输出同步使能脉冲信号。类似的，d 输入在周期 7 中切换为低电平，到周期 10 时，高电平信号已通过三个同步触发器传播，在第9周期，q2和q3触发器的输出具有不同的极性，进而导致异或门输出同步使能脉冲信号。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515163009157.png" alt="image-20220515163009157"></p><center>同步使能脉冲信号的生成逻辑电路和等效的符号（右侧）</center><p>除了生成d输入对应电平的输出脉冲信号外，同步使能脉冲生成电路还有一个q输出，其延迟d输入三个时钟周期。q输出经常用作反馈信号，并作为确认信号通过发送时钟域中的另一个同步使能脉冲生成电路。</p><p>下图显示了典型的发送-接收触发脉冲生成电路的设计。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515163552645.png" alt="image-20220515163552645"></p><center>MCP公式 toggle-pulse 生成电路</center><p>对于该技术，接收时钟域需要有适当的逻辑电路在检测到脉冲时采集数据，因为脉冲将仅在每个多周期数据字的一个接收时钟周期内有效。</p><h3 id="闭环-带反馈的MCP公式"><a href="#闭环-带反馈的MCP公式" class="headerlink" title="闭环 - 带反馈的MCP公式"></a>闭环 - 带反馈的MCP公式</h3><p>使用MCP公式的一项重要技术是将使能信号作为确认信号传回发送时钟域，如下图所示。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220515163937198.png" alt="image-20220515163937198"></p><center>带确认信号的MCP公式切换脉冲信号生成电路</center><p>对于上图所示实例，当数据寄存器的输入数据有效时，接收时钟域的WAIT-READY、1状态FSM会向接收逻辑电路发送一个有效信号，直到接收逻辑电路通过置位bload信号确认后，才会实际加载数据。在加载数据前，没有任何反馈信号会发送到发送时钟域，然后将b_ack信号带着自动反馈信号与以MCP公式相同的方式送回。</p><p>该反馈路径要求在捕获数据和发送反馈前在接收时钟域采取行动。</p><h2 id="同步计数器"><a href="#同步计数器" class="headerlink" title="同步计数器"></a>同步计数器</h2><p>original</p><h1 id="单比特同步策略"><a href="#单比特同步策略" class="headerlink" title="单比特同步策略"></a>单比特同步策略</h1><p>为避免亚稳态，应尝试使MTBF尽量大。采用双锁存器可以改善该问题：</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/4.png" alt="4"></p><p>此时，b_dat2的MTBF由以下公式可以得出：</p><script type="math/tex; mode=display">MTBF=e^{t_r / \tau} / T_0fa \times e^{t_r / \tau} / T_0 fa</script><p>如果同样代入上一节中所提供的参数进行计算，则可得b_dat2的MTBF为9.57*109(years)，由该结果可看出，采用双锁存器可以消除亚稳态问题。</p><p><strong>注意A</strong></p><p>时钟域B两级同步的寄存器与时钟域A的输出寄存器之间不能由组合逻辑—组合逻辑电路各个输入信号的不一致性以及组合逻辑内部路径的延时时间不一样，运算后的信号存在毛刺，如下图所示，由此导致B时钟域上升沿采集信号无法预知。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/5.png" alt="5"></p><p>因此要想在B时钟域内能够采集到稳定的信号，时钟域A的输出信号必须经过触发器整形，保证在一个时钟周期中是稳定的信号。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/6.png" alt="6"></p><font color="red">**注意B**</font><p>$Clock-Gating Enable$信号未经过异步处理</p><p>如下图所示的A信号经过A时钟域触发器整形后，再送到两级DFF同步器处理，但注意F2的使能信号Enable信号也是从A时钟域所得，当Enable信号变化时，由于时钟域不一样，无法保证使能后的B时钟域信号采集数据时满足Setup/Hold Time要求，此时F2输出信号也就变得无法预测。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/7.PNG" alt="7"></p><p><strong>注意C</strong></p><p>当快时钟域是慢时钟域频率的1.5倍或以上时，较慢频率的信号同步到较快频率时钟域通常不成问题—快采慢比慢采快存在的潜在问题更少，所以通常快采慢情形采取简单的两级触发同步器在时钟域间传递单个信号即可。</p><p>即使采样信号比采用周期长，也可能面临信号改变正好处于时钟沿的SetUp和Hold Violation区域的问题，解决方案：</p><ul><li>开环地控制信号的长度</li></ul><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220510000511421.png" alt="image-20220510000511421"></p><p>由此不需要知道接收时钟域的边沿信息，只需要在发送域保证发送信号长度即可</p><ul><li>闭环控制<font color="red">？？？</font></li></ul><p>采用反馈信号自动延长快时钟域的信号，将A时钟域传输信号打一拍送到B时钟域进行双触发器同步，同步后的信号再反馈回A时钟域，A中再进行双触发器同步，当A域中反馈同步信号为高时才将采样信号拉低，此时会有更高的延时以及更多同步触发器，但同时也能保证出现采样信号为未知的可能性更低。</p><h1 id="多比特同步策略"><a href="#多比特同步策略" class="headerlink" title="多比特同步策略"></a>多比特同步策略</h1><p>对于多比特的控制信号或数据信号跨时钟域传输的问题，解决方案通常有：</p><ul><li>将信号合并为单Bit</li><li>Multi-Cycle Path(MCP) 使用同步信号</li><li>Grey码</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

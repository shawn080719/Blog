<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FPGA Routing Architecture Between Tiles</title>
      <link href="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/"/>
      <url>/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/</url>
      
        <content type="html"><![CDATA[<h1 id="基本结构-—-Island"><a href="#基本结构-—-Island" class="headerlink" title="基本结构 — $Island$"></a>基本结构 — $Island$</h1><h2 id="Switch-Block"><a href="#Switch-Block" class="headerlink" title="$Switch Block$"></a>$Switch Block$</h2><p>目前通用的几种交换块结构为：$Universal, Disjoint, Wil$</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/SwitchBlock.PNG" alt="SwitchBlock"></p><p>$Disjoint$类型会导致路由线路被限制在同一类型轨道内，如在该图中0通道输入仅能连接到0轨道输出，因此任何由$CLB$导入0轨道的信号都不能通过其他轨道路由，而$Universal$和$Wilton$型则属于全连接类型，且其$Top$结构仅需更少的布线轨道和晶体管来实现。</p><h2 id="描述参数"><a href="#描述参数" class="headerlink" title="描述参数"></a>描述参数</h2><ul><li>$k$      $LUT$输入    $3 to 7 inputs$</li><li>$N$      $Cluster$ 中 $LUT$ 数量    $1 to 10 LUTs$</li><li>$I$      $CLB$输入    $4 to 40 inputs$</li><li>$W $    通道宽度，表示每个通道中的track数    $10 to 60 tracks$</li><li>$F_s$    交换块灵活度$(Flexibility of Swtich Block)$    表示发生在开关块中轨道上的可编程连接的数量</li><li>$F_{c_{in}}$    连接块灵活度$(Flexibility of ConnectionBlock)$表示$CLB$ 输入可连接的轨道数与总轨道数之比    $0.1 to 1.0$</li><li>$F_{c_{out}} $   连接块灵活度$(Flexibility of ConnectionBlock)$表示$CLB$ 输出可连接的轨道数与总轨道数之比    $0.1 to 1.0$</li></ul><span id="more"></span><h2 id="物理层部署"><a href="#物理层部署" class="headerlink" title="物理层部署"></a>物理层部署</h2><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/physical layer.PNG" alt="physical layer"></p><p>对于$F_s = 3$的交换块，其任意输入都有三个潜在的连接对象；同理，任意输出都有三个潜在的输入连接对象。因此如左图所示的交换快Top结构可具体为右图中的多路选择器，其晶体管级实现根据具体情况决定。</p><h1 id="TOP-实现"><a href="#TOP-实现" class="headerlink" title="$TOP$实现"></a>$TOP$实现</h1><h2 id="Single-Drive-Routing"><a href="#Single-Drive-Routing" class="headerlink" title="$Single Drive Routing$"></a><a href="https://www.eecg.utoronto.ca/~jayar/pubs/luu/luufpga09.pdf">$Single Drive Routing$</a></h2><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/1.PNG" alt="1"></p><p>在$Single Drive Routing$结构中，可编程性是通过在驱动器的输入上使用多路复用器来实现的，每个布线轨道都只有一个物理驱动器，这种对单个驱动器的限制意味着逻辑块输出只能连接到其驱动器与逻辑块相邻的布线轨道，以避免与相邻逻辑集群的布线过长。典型的单驱动器布线架构将驱动器放置在布线的一端而不是中间，每根线只能在特定方向发送信号。</p><p>目前，<a href="http://www.altera.com/literature/hb/ stratix-iv/stratix4_handbook.pdf">$Altera$</a>及<a href="http://www.altera.com/literature/hb/ stratix-iv/stratix4_handbook.pdf">$Xilinx$</a>最近推出的所有$FPGA$设备都特定使用单驱动器路由架构。</p><h2 id="基于定长路由线-tile-的-fabric-生成"><a href="#基于定长路由线-tile-的-fabric-生成" class="headerlink" title="基于定长路由线$tile$的$fabric$生成"></a><a href="https://www.eecg.utoronto.ca/~vaughn/papers/fpga2000.pdf">基于定长路由线$tile$的$fabric$生成</a></h2><p>通常构建$fabric$需要根据每个$tile$的具体连接情况单独指定其开关块和连接块。如果只是简单的对每个$tile$进行路由通路复制，则会出现如下图所示的问题——部分$CLB$输出引脚无法通过路由轨道驱动部分其他$CLB$的输入引脚：</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/ReplicationgChannel.PNG" alt="ReplicationgChannel"></p><p>造成该问题的原因，是在$Routing$中采用的$Segment$无法在中端加入开关——否则实际布线时就会编程两根较短导线，而单纯的重复相同$tile$的布局无法针对该路由结构的情况进行针对性调整。</p><p>可通过规律性调整路由线起点解决该问题。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/Adjust_before.PNG" alt="Adjust_before"></p><p>如上图所示的$fabric$结构，将每个tile对应的水平路由轨道从下到上分别命名为$Channel0-2$，垂直路由轨道从左到右分别命名为$Channel0-2$；首先考虑水平$Channel$，对于轨道0中$track0$线段的左端与满足如下条件的逻辑块对齐：</p><script type="math/tex; mode=display">(i + 2) module 3 = 0</script><p>其中$ i $是逻辑块的水平(x)坐标。则对于轨道1中$track0$线段的左端与满足如下条件的逻辑块对齐：</p><script type="math/tex; mode=display">(i + 3) module3 = 0</script><p>对于其他编号的$track$的起点则要求顺序后移——随$Channel$编号增加方向；</p><p>垂直方向通道判断$Segment$起点方法公式与水平通道相同(编号规则不改变)，且执行类似的起点后移——通道$i+1$中每个$Segment$起点相对于通道i中的起点向后移动一个$CLB$。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/Adjust_after.PNG" alt="Adjust_after"></p><p>再更改其$Top$结构，使其每个$Tile$路由结构相同，便于复制生成目标大小的$fabric$。</p><h1 id="Detailed-Routing-Architecture"><a href="#Detailed-Routing-Architecture" class="headerlink" title="$Detailed Routing Architecture$"></a><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1067.891&amp;rep=rep1&amp;type=pdf">$Detailed Routing Architecture$</a></h1><p>影响FPGA整体性能的一个主要因素是路由开关的选择，路由开关可由输入复用传输晶体管、缓冲器和输出解复用晶体管的任意组合进行建模。其组合中在电气上可行的5中结构如下表所示：</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/DirectDriveMux.PNG" alt="DirectDriveMux"></p><ul><li>缓冲器</li><li>缓冲器和输出传输晶体管</li><li>传输晶体管</li><li>直接驱动多路复用器</li><li>带缓冲器的传输晶体管多路复用器和输出多路复用器</li></ul><p>缓冲器没有任何执行可编程路由的能力，但可能部署在架构中的不同位置以重新为信号供电。</p><p>在本论文中，尝试使用不同线长占比的$Routing$结构对同一基准电路进行布线，并检测其消耗资源情况，如下图显示对包含$50\%Segment$长度4和$50\%Segment$长度16，以及$50\%Segment$长度4和$50\%Segment$长度8两种布线结构使用直接驱动$(Direct Routing)$的效果。其基本架构在两种布线结构中都使用了$50\%$的传输晶体管和$50\%$的缓冲开关。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/fraction direct routing.PNG" alt="fraction direct routing"></p><center>Average critical path delay for varying fraction of direct-drive routing wires</center><p>在实验中，$fabric$路由面积随着直接驱动开关的使用而单调减小。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/Channel Width Required for varying fraction of DDW.PNG" alt="Channel Width Required for varying fraction of DDW"></p><center>Channel Width required for varing fraction of direct-drive wires</center><p>$4/8$架构所需的通道宽度大致恒定，而由于单个驱动点对$Segement$为16的导线形成了更严格的布线约束，因此$4/16$架构对应的通道宽度有所增加。</p><p><img src="/2022/05/09/FPGA%20Routing%20Architecture%20Between%20Tiles/Total Routing Area.PNG" alt="Total Routing Area"></p><center>Total routing area required for varying fraction of direct-drive wires</center><p>尽管$4/8$结构导致通道宽度增加，但总布线面积回随着布线多路复用器输入上的小晶体管替换宽布线晶体管而减少。因此如上图所示，在两种现场组合中的任何一种中，$100\%$直接驱动多路复用器都会形成速度最快和面积最小的$fabric$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xilinx的RAM使用</title>
      <link href="/2022/05/09/Xilinx%E7%9A%84RAM%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/09/Xilinx%E7%9A%84RAM%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="RAM类型"><a href="#RAM类型" class="headerlink" title="RAM类型"></a>RAM类型</h1><p>单端RAM —— Single Port RAM</p><p>伪双端RAM —— Sinple Dual Port RAM</p><p>真双端RAM —— True Dual Port RAM</p><span id="more"></span><h1 id="接口区别"><a href="#接口区别" class="headerlink" title="接口区别"></a>接口区别</h1><p><img src="/2022/05/09/Xilinx%E7%9A%84RAM%E4%BD%BF%E7%94%A8/1.PNG" alt="1"></p><p>单端口：具备一套地址总线，仅通过一个端口对存储进行读写访问；读写无法同时进行。</p><p>伪双端口：具备两套地址总线，提供两个端口（A、B），但每个端口仅负责一项功能，如通过A端口进行写访问，通过B端口进行读访问；读写可并行执行。</p><p>真双端口：具备两套地址总线，提供两个端口（A、B），且每个端口均可负责读写功能；双端口读写均可并行执行。</p><p>————————————————————同时进行读写时 不能对同一地址进行操作 不管何种类型RAM 实际内部都是同一块地址Mem（在FPGA中实现时的资源消耗量也可看出）———————————————————-</p><p>综上：对于双端口RAM，在外部控制时若只将A端口用作写、B端口用作读，则实际实现和伪双端口RAM相同；</p><p>双端口ROM和双端口RAM相同，可实现两个端口同时读取ROM中的数据，所以当两个Processor同时访问同一数据时，就不需要例化两个相同的ROM浪费资源。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Xilinx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vivado的Debug实现方法</title>
      <link href="/2022/05/09/Vivado%E7%9A%84Debug%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2022/05/09/Vivado%E7%9A%84Debug%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一-例化ILA-IP核"><a href="#一-例化ILA-IP核" class="headerlink" title="一 例化ILA IP核"></a>一 例化ILA IP核</h1><p>​    通过IP核配置的方法配置检测信号，主要包括数据：信号数量、位宽、激发方式（一般通过Data And方式激活）—— 该操作是在综合前通过添加IP在原本电路设计中增加额外的Debug电路来实现纠错。</p><h1 id="二-代码标记"><a href="#二-代码标记" class="headerlink" title="二 代码标记"></a>二 代码标记</h1><p>​    通过在代码中对信号直接标记的方法添加Debug，在综合后通过 set up debug 选项实现Debug模块的添加，具体流程如下“网表标记”所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* Mark_debug = &quot;TRUE&quot; *)regsignal_A;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="三-通过网表标记"><a href="#三-通过网表标记" class="headerlink" title="三 通过网表标记"></a>三 通过网表标记</h1><p>​    该操作需要在综合后在网表中设置Mark Debug（或在综合后的电路原理图中）；</p><p>​    在标记Debug后，就等于选择了需要Debug的信号，之后再综合设置中设置Debug参数。</p><p><img src="/2022/05/09/Vivado%E7%9A%84Debug%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/2.PNG" alt="2"></p><p>*该方法无法对所有信号实现Debug，例如模块的直接输入信号就无法添加Mark Debug（可通过添加Buffer模块实现添加）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vivado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog的分层事件队列</title>
      <link href="/2022/05/09/Verilog%E7%9A%84%E5%88%86%E5%B1%82%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/"/>
      <url>/2022/05/09/Verilog%E7%9A%84%E5%88%86%E5%B1%82%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>仿真器首先按照仿真时间对事件进行排序，然后再在当前仿真时间里按照事件的优先级顺序进行排序。</p><p>活跃事件是优先级最高的时间，在活跃事件之间，它们的执行顺序是随机的。</p><p>两个缩写：$RHS(right-hand-side)$和$LHS(left-hand-side)$。</p><p>前者指等式右边的表达式或者变量$(RHS expression or RHS variable)$，后者指等式左边的表达式或者变量$(LHS expression or LHS variable)$。</p><p>由上表可知，阻塞赋值属于活跃事件，会立刻执行，这就是阻塞赋值<em>计算完毕，立即更新</em>的原因。此外，由于在分层事件队列中，只有将活跃事件中排在前面的事件调出，并执行完毕后，才能够执行下面的事件，这就可以解释阻塞赋值的第二个特点。</p><p>同样由上表可知，非阻塞赋值的$RHS$计算属于活跃事件，而非阻塞赋值的更新事件排在非活跃事件之后，因此只有仿真队列中所有的活跃事件和非活跃事件都执行完毕后，才轮到非阻塞赋值更新事件，这就是非阻塞赋值必须分两拍完成的原因。</p><span id="more"></span><h2 id="阻塞赋值特点："><a href="#阻塞赋值特点：" class="headerlink" title="阻塞赋值特点："></a><strong>阻塞赋值特点：</strong></h2><ul><li><p>$RHS$的表达式计算和$LHS$的赋值更新，这两个动作之间不能插入其他动作，即所谓计算完毕，立即更新。</p></li><li><p>所谓阻塞赋值就是在一个begin…end块中的多个阻塞赋值语句，只有上一句完全执行完毕后，才会执行下一语句。</p></li></ul><h2 id="非阻塞赋值程序的执行："><a href="#非阻塞赋值程序的执行：" class="headerlink" title="非阻塞赋值程序的执行："></a><strong>非阻塞赋值程序的执行：</strong></h2><p>非阻塞赋值，$RHS$的计算表达式和$LHS$的赋值更新分两个节拍执行。首先，应该是$RHS$表达式计算，得到新值后并不立即赋值，而是放在事件队列中等待，直到当前仿真时刻的后期才执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨时钟域处理方案</title>
      <link href="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/"/>
      <url>/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><strong><em>Clock Domain Crossing Solution</em></strong></p><p><a href="https://www.cnblogs.com/lyc-seu/p/12441366.html">本文参考文章A</a></p><h1 id="异步时序定义"><a href="#异步时序定义" class="headerlink" title="异步时序定义"></a>异步时序定义</h1><p>异步时序设计指的是在设计中有两个或以上的时钟， 且时钟之间是同频不同相或不同频率的关系。而异步时序设计的关键就是把数据或控制信号正确地进行跨时钟域传输。</p><span id="more"></span><h1 id="亚稳态"><a href="#亚稳态" class="headerlink" title="亚稳态"></a>亚稳态</h1><p>触发器具备其规定的建立$(setup)$和保持$(hold)$时间，在该时间参数内，输入信号在时钟的上升沿期间不能改变，否则会导致采集信号结果不可预知，即亚稳态。</p><p>亚稳态是指在设计的正常运行阶段的某个时间点，在一段时间内呈现不稳定的0或1状态的信号。</p><p>在多时钟设计中，无法避免亚稳态，但可以采取策略抵消亚稳态的不利影响。</p><p>触发器进入亚稳态的时间可以用参数$MTBF(Mean Time Between Failures)$来描述，即触发器采样失败的时间间隔，其公式如下所示：</p><script type="math/tex; mode=display">MTBF=e^ {t_r/\tau} / T_0fa</script><p>其中：</p><ul><li>$t_r$  分辨时间 (时钟沿开始)</li><li>$\tau, T_0   $ 触发器参数</li><li>$f  $  采样时钟频率</li><li>$a  $  异步事件触发频率</li></ul><p>通常，MTBF越大说明系统采样失败的可能性越小。因此，对于高速设计，MTBF更容易发生。对于一个典型的0.25um工艺的ASIC库中的一个触发器，我们取如下参数：</p><script type="math/tex; mode=display">t_r=2.3ns, \tau=0.31ns, T_0= 9.6as, f=100MH_Z, a=10MH_Z, MTBF = 2.01 days</script><p>即触发器以$100MH_Z$工作，假设异步时间触发的频率，也就是数据变化的频率与采样时钟的频率相同。使用$10MH_Z$频率进行采样，每个上升沿数据都会发生变化，由数据可知没两天就可能会采集到一次亚稳态。如果使用单锁存器同步，则采样时钟上升沿采集原始信号数据时很可能导致采集信号亚稳态。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/3.png" alt="3"></p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220510233046580.png" alt="image-20220510233046580"></p><center>异步时钟的同步失败</center><h1 id="单比特同步策略"><a href="#单比特同步策略" class="headerlink" title="单比特同步策略"></a>单比特同步策略</h1><p>为避免亚稳态，应尝试使MTBF尽量大。采用双锁存器可以改善该问题：</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/4.png" alt="4"></p><p>此时，b_dat2的MTBF由以下公式可以得出：</p><script type="math/tex; mode=display">MTBF=e^{t_r / \tau} / T_0fa \times e^{t_r / \tau} / T_0 fa</script><p>如果同样代入上一节中所提供的参数进行计算，则可得b_dat2的MTBF为9.57*109(years)，由该结果可看出，采用双锁存器可以消除亚稳态问题。</p><p><strong>注意A</strong></p><p>时钟域B两级同步的寄存器与时钟域A的输出寄存器之间不能由组合逻辑—组合逻辑电路各个输入信号的不一致性以及组合逻辑内部路径的延时时间不一样，运算后的信号存在毛刺，如下图所示，由此导致B时钟域上升沿采集信号无法预知。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/5.png" alt="5"></p><p>因此要想在B时钟域内能够采集到稳定的信号，时钟域A的输出信号必须经过触发器整形，保证在一个时钟周期中是稳定的信号。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/6.png" alt="6"></p><font color="red">**注意B**</font><p>$Clock-Gating Enable$信号未经过异步处理</p><p>如下图所示的A信号经过A时钟域触发器整形后，再送到两级DFF同步器处理，但注意F2的使能信号Enable信号也是从A时钟域所得，当Enable信号变化时，由于时钟域不一样，无法保证使能后的B时钟域信号采集数据时满足Setup/Hold Time要求，此时F2输出信号也就变得无法预测。</p><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/7.PNG" alt="7"></p><p><strong>注意C</strong></p><p>当快时钟域是慢时钟域频率的1.5倍或以上时，较慢频率的信号同步到较快频率时钟域通常不成问题—快采慢比慢采快存在的潜在问题更少，所以通常快采慢情形采取简单的两级触发同步器在时钟域间传递单个信号即可。</p><p>即使采样信号比采用周期长，也可能面临信号改变正好处于时钟沿的SetUp和Hold Violation区域的问题，解决方案：</p><ul><li>开环地控制信号的长度</li></ul><p><img src="/2022/05/09/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/image-20220510000511421.png" alt="image-20220510000511421"></p><p>由此不需要知道接收时钟域的边沿信息，只需要在发送域保证发送信号长度即可</p><ul><li>闭环控制<font color="red">？？？</font></li></ul><p>采用反馈信号自动延长快时钟域的信号，将A时钟域传输信号打一拍送到B时钟域进行双触发器同步，同步后的信号再反馈回A时钟域，A中再进行双触发器同步，当A域中反馈同步信号为高时才将采样信号拉低，此时会有更高的延时以及更多同步触发器，但同时也能保证出现采样信号为未知的可能性更低。</p><h1 id="多比特同步策略"><a href="#多比特同步策略" class="headerlink" title="多比特同步策略"></a>多比特同步策略</h1><p>对于多比特的控制信号或数据信号跨时钟域传输的问题，解决方案通常有：</p><ul><li>将信号合并为单Bit</li><li>Multi-Cycle Path(MCP) 使用同步信号</li><li>Grey码</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
